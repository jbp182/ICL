PARSER_BEGIN(Parser)


/** ID lister. */
package Components;
import LanguageComponents.Environments.CodeBlock;
import LanguageComponents.Environments.CompilerEnvironment;
import LanguageComponents.Environments.Environment;
import LanguageComponents.Nodes.*;
import LanguageComponents.Nodes.ArithmeticOperators.*;
import LanguageComponents.Nodes.FuncionalCore.*;
import LanguageComponents.Nodes.ImperativeCore.*;
import LanguageComponents.Nodes.LogicOperators.*;
import LanguageComponents.Nodes.RelationalOperators.*;
import java.io.FileInputStream;
import java.io.File;
import java.util.LinkedList;

public class Parser {

  /** Main entry point. */
  public static void main(String args[]) throws  Exception {

    if(args.length > 1 && args[0].equals("-f")){
        compile(args[1]);
        return;
    }

    Parser parser = new Parser(System.in);
    ASTNode exp;

    while (true) {
        try {
        exp = parser.Start();
        exp.eval(new Environment(null)).show();
        } catch (Exception e) {
          System.out.println ("Syntax Error!\n" + e.getMessage());
          parser.ReInit(System.in);
        }
    }
  }

  private static void compile(String fileName) throws Exception{
      File f = new File(fileName);
      Parser parser = new Parser(new FileInputStream(f));
      ASTNode exp = parser.Start();
      CodeBlock blk = new CodeBlock();
      exp.compile(new CompilerEnvironment(null),blk);
      blk.dump("Main.j");
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
  |
  < LET: "let" >
  |
  < IN: "in" >
  |
  < END: "end" >
  |
  < COMMA: "," >
  |
  < NOT: "~" >
  |
  < ISEQ: "==" >
  |
  < AND: "&&" >
  |
  < OR: "||" >
  |
  < GT: ">" >
  |
  < LT: "<" >
  |
  < GE: ">=" >
  |
  < LE: "<=" >
  |
  < EQ: "=" >
  |
  < NEW: "new" >
  |
  < SEQ: ";" >
  |
  < ASSIGN: ":=" >
  |
  < DESREF: "!" >
  |
  < IF: "if" >
  |
  < THEN: "then" >
  |
  < ELSE: "else" >
  |
  < WHILE: "while" >
  |
  < DO: "do" >
  |
  < BOOL: ("true"|"false") >
  | 
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

ASTNode Start():
{ ASTNode t; }
{
   ( t = Em() <EL> )
   { return t; }
}

ASTNode Em():
{ Token op;
  ASTNode t1, t2; }
{
  t1 = W() ( ( op=< SEQ >) t2=W()
  				{ t1 = new ASTSeq(t1,t2); }
			)*
	{ return t1; }
}

ASTNode W():
{ Token op;
  ASTNode t1, t2; }
{
  	t1 = ExpLine() ( ( op=<AND> | op=<OR> ) t2=ExpLine()
  					{ if (op.kind == AND)
  						   t1 = new ASTAnd(t1,t2);
  					  else t1 = new ASTOr(t1,t2);
  					}
  				 )?
	 { return t1; }
}

ASTNode ExpLine():
{ Token op;
  ASTNode t1, t2; }
{
  	t1 = Exp() ( ( op=< ISEQ > | op=< GE > | op=< LE >
  					| op=< GT > | op=< LT > ) t2=Exp()
  				{ if (op.kind == ISEQ)
  						t1 = new ASTEquals(t1,t2);
				  else if (op.kind == GT)
				  		t1 = new ASTGreater(t1,t2);
			  	  else if (op.kind == LT)
				  		t1 = new ASTLower(t1,t2);
		  		  else if (op.kind == GE)
				  		t1 = new ASTGreaterEqual(t1,t2);
				  else if (op.kind == LE)
				  		t1 = new ASTGreater(t1,t2);
  			    }
  			  )*
    { return t1; }
}
    
  

ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
     t1=Term() ( ( op=<PLUS> | op=<MINUS> ) t2=Term() 
                 { if (op.kind == PLUS) 
                         t1 = new ASTPlus(t1,t2);
                   else  t1 = new ASTSub(t1,t2);
                 } 
                  ) *
     { return t1; } 
}

ASTNode Term() :
{ Token op;
  ASTNode f1, f2;}
{
     f1=Fact() ( < ASSIGN > f2=W() { f1 = new ASTAssign(f1,f2); }
     	       | ( ( op=<TIMES> | op=<DIV> ) f2=Fact() 
			     { if (op.kind == TIMES)
			     		f1 = new ASTMul(f1,f2);
			     	else f1 = new ASTDiv(f1,f2);
			   	 }
			      )* 
			   )
	{ return f1; }
}


ASTNode Fact() :
{ Token n, id, id1, id2; 
  ASTNode t, init1, init2, body;
  LinkedList<String> ids;
  LinkedList<ASTNode> inits;}
{
    (  n=< Num >   {  t = new ASTNum(Integer.parseInt(n.image)); }
   | <LPAR> t=Exp() <RPAR>
   | < MINUS > t=Fact() { t = new ASTMul(new ASTNum(-1), t); }
   | < PLUS > t=Fact()
   | id=< Id > { t = new ASTId( id.image ); }
   | n =< BOOL > { t = new ASTBool( n.image ); }
   | < NEW > t=Fact() { t = new ASTNewRef( t ); }
   | < DESREF > t=Fact() { t = new ASTDesRef( t ); }
   | < IF > t=Em() < THEN > init1=Em() < ELSE > init2=Em() < END >
   			{ t = new ASTIf( t, init1, init2 ); }
   | < WHILE > t=Em() < DO > body=Em() < END >
   			{ t = new ASTWhile(t,body); }
   | < LET > id1 = < Id > <EQ > init1=Exp()
   			{	ids = new LinkedList();
   		  		inits = new LinkedList();
   		  		ids.add(id1.image); inits.add(init1); }
   		( < COMMA > id2 = < Id > <EQ > init2=Exp()
   			{ ids.add(id2.image); inits.add(init2); }
   		)*
   		< IN > body=Exp() < END >
   		
   		{ t = new ASTLet(ids, inits, body); }
   )
   { return t; }
}




















